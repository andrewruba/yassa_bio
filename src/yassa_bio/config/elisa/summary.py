"""
Canonical container for *final* ELISA results.

Nothing here is used in calculation—only for returning / serialising
outputs after the analysis pipeline has finished.
"""

from __future__ import annotations
from datetime import datetime, timezone
from typing import List, Dict, Optional, Literal

from pydantic import BaseModel, Field


class CurveParameter(BaseModel):
    """One fitted parameter from the 4-PL/5-PL (or other) model."""

    name: str  # e.g. "A", "B", "C", "D", "E"
    value: float
    stderr: Optional[float] = None  # standard error if available


class SampleResult(BaseModel):
    well: str  # "E3"
    sample_id: Optional[str] = None  # if linked to metadata
    concentration: float  # back-calculated (after dilution)
    units: str  # "pg/mL"
    replicate: Optional[int] = None
    qc_flag: Optional[Literal["OK", "FAIL", "WARN"]] = "OK"
    notes: Optional[str] = None  # any text generated by QC rules


class ELISASummaryQC(BaseModel):
    """High-level QC indicators; expand as your rules mature."""

    r_squared: float
    max_cv_percent: float
    parallelism_ok: Optional[bool] = None
    overall_pass: bool


class ElisaResultBundle(BaseModel):
    """
    Returned by the evaluation pipeline (det_ctx.results).

    It is intentionally **light-weight**: just primitives that are easy to
    serialise to JSON, persist in Firestore, or embed in a PDF report.
    """

    plate_id: str
    curve_model: str = "4PL"  # “4PL”, “5PL”, …
    parameters: List[CurveParameter]

    # keyed by well → SampleResult  (makes look-ups trivial)
    samples: Dict[str, SampleResult]

    qc_summary: ELISASummaryQC

    generated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    generated_by: str = "elisa_evaluation_pipeline-dev"

    # optional paths to artifacts produced downstream
    report_pdf: Optional[str] = None  # gs://… or signed URL
    raw_results_csv: Optional[str] = None  # tidy results table
